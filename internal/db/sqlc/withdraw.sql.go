// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: withdraw.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelWithdrawalById = `-- name: CancelWithdrawalById :one
DELETE FROM withdrawals
WHERE withdrawal_id = $1
AND processing_withdrawal_id IS NULL
RETURNING withdrawal_id, account_id, amount, priority_fee
`

type CancelWithdrawalByIdRow struct {
	WithdrawalID int64 `json:"withdrawal_id"`
	AccountID    int64 `json:"account_id"`
	Amount       int64 `json:"amount"`
	PriorityFee  int64 `json:"priority_fee"`
}

func (q *Queries) CancelWithdrawalById(ctx context.Context, withdrawalID int64) (CancelWithdrawalByIdRow, error) {
	row := q.db.QueryRow(ctx, cancelWithdrawalById, withdrawalID)
	var i CancelWithdrawalByIdRow
	err := row.Scan(
		&i.WithdrawalID,
		&i.AccountID,
		&i.Amount,
		&i.PriorityFee,
	)
	return i, err
}

const cleanOldWithdrawals = `-- name: CleanOldWithdrawals :many
DELETE FROM processing_withdrawals
WHERE create_time < $1
AND withdrawal_status = 'succeeded'
RETURNING processing_withdrawal_id, transaction_digest, transaction_bytes_base64, total_priority_fee, withdrawal_status, create_time
`

// 'processing' withdrawals must wait being marked to avoid losing money
func (q *Queries) CleanOldWithdrawals(ctx context.Context, cleanTime pgtype.Timestamptz) ([]ProcessingWithdrawal, error) {
	rows, err := q.db.Query(ctx, cleanOldWithdrawals, cleanTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessingWithdrawal{}
	for rows.Next() {
		var i ProcessingWithdrawal
		if err := rows.Scan(
			&i.ProcessingWithdrawalID,
			&i.TransactionDigest,
			&i.TransactionBytesBase64,
			&i.TotalPriorityFee,
			&i.WithdrawalStatus,
			&i.CreateTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProcessingWithdrawals = `-- name: ListProcessingWithdrawals :many
SELECT
  processing_withdrawal_id, transaction_digest, transaction_bytes_base64, total_priority_fee, withdrawal_status, create_time
FROM processing_withdrawals
WHERE withdrawal_status = 'processing'
ORDER BY total_priority_fee DESC, create_time
LIMIT $1
OFFSET $2
`

type ListProcessingWithdrawalsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListProcessingWithdrawals(ctx context.Context, arg ListProcessingWithdrawalsParams) ([]ProcessingWithdrawal, error) {
	rows, err := q.db.Query(ctx, listProcessingWithdrawals, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProcessingWithdrawal{}
	for rows.Next() {
		var i ProcessingWithdrawal
		if err := rows.Scan(
			&i.ProcessingWithdrawalID,
			&i.TransactionDigest,
			&i.TransactionBytesBase64,
			&i.TotalPriorityFee,
			&i.WithdrawalStatus,
			&i.CreateTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWithdrawals = `-- name: ListWithdrawals :many
SELECT
  withdrawal_id, account_id, withdraw_address, amount, priority_fee, processing_withdrawal_id, create_time
FROM withdrawals
WHERE account_id = $1
ORDER BY create_time
LIMIT $2
OFFSET $3
`

type ListWithdrawalsParams struct {
	AccountID int64 `json:"account_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) ListWithdrawals(ctx context.Context, arg ListWithdrawalsParams) ([]Withdrawal, error) {
	rows, err := q.db.Query(ctx, listWithdrawals, arg.AccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Withdrawal{}
	for rows.Next() {
		var i Withdrawal
		if err := rows.Scan(
			&i.WithdrawalID,
			&i.AccountID,
			&i.WithdrawAddress,
			&i.Amount,
			&i.PriorityFee,
			&i.ProcessingWithdrawalID,
			&i.CreateTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const processWithdrawals = `-- name: ProcessWithdrawals :many
UPDATE withdrawals
  SET
    processing_withdrawal_id = $1
  WHERE withdrawal_id = ANY($2::bigint[])
  RETURNING withdrawal_id, account_id, withdraw_address, amount, priority_fee, processing_withdrawal_id, create_time
`

type ProcessWithdrawalsParams struct {
	ProcessingWithdrawalID pgtype.Int8 `json:"processing_withdrawal_id"`
	WithdrawalIds          []int64     `json:"withdrawal_ids"`
}

func (q *Queries) ProcessWithdrawals(ctx context.Context, arg ProcessWithdrawalsParams) ([]Withdrawal, error) {
	rows, err := q.db.Query(ctx, processWithdrawals, arg.ProcessingWithdrawalID, arg.WithdrawalIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Withdrawal{}
	for rows.Next() {
		var i Withdrawal
		if err := rows.Scan(
			&i.WithdrawalID,
			&i.AccountID,
			&i.WithdrawAddress,
			&i.Amount,
			&i.PriorityFee,
			&i.ProcessingWithdrawalID,
			&i.CreateTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectCandidateWithdrawals = `-- name: SelectCandidateWithdrawals :many
SELECT
  withdrawal_id, account_id, withdraw_address, amount, priority_fee, processing_withdrawal_id, create_time
FROM withdrawals 
WHERE processing_withdrawal_id IS NULL
ORDER BY priority_fee DESC, create_time
LIMIT $1
FOR UPDATE SKIP LOCKED
`

func (q *Queries) SelectCandidateWithdrawals(ctx context.Context, retrieveCount int32) ([]Withdrawal, error) {
	rows, err := q.db.Query(ctx, selectCandidateWithdrawals, retrieveCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Withdrawal{}
	for rows.Next() {
		var i Withdrawal
		if err := rows.Scan(
			&i.WithdrawalID,
			&i.AccountID,
			&i.WithdrawAddress,
			&i.Amount,
			&i.PriorityFee,
			&i.ProcessingWithdrawalID,
			&i.CreateTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setWithdrawalBatch = `-- name: SetWithdrawalBatch :one
INSERT INTO processing_withdrawals (
  transaction_digest,
  transaction_bytes_base64,
  total_priority_fee,
  withdrawal_status
) VALUES (
  $1, $2, $3, 'processing'
)
RETURNING processing_withdrawal_id, transaction_digest, transaction_bytes_base64, total_priority_fee, withdrawal_status, create_time
`

type SetWithdrawalBatchParams struct {
	TransactionDigest      string `json:"transaction_digest"`
	TransactionBytesBase64 string `json:"transaction_bytes_base64"`
	TotalPriorityFee       int64  `json:"total_priority_fee"`
}

func (q *Queries) SetWithdrawalBatch(ctx context.Context, arg SetWithdrawalBatchParams) (ProcessingWithdrawal, error) {
	row := q.db.QueryRow(ctx, setWithdrawalBatch, arg.TransactionDigest, arg.TransactionBytesBase64, arg.TotalPriorityFee)
	var i ProcessingWithdrawal
	err := row.Scan(
		&i.ProcessingWithdrawalID,
		&i.TransactionDigest,
		&i.TransactionBytesBase64,
		&i.TotalPriorityFee,
		&i.WithdrawalStatus,
		&i.CreateTime,
	)
	return i, err
}

const setWithdrawalSuccess = `-- name: SetWithdrawalSuccess :one
UPDATE processing_withdrawals
  SET
    withdrawal_status = 'succeeded'
  WHERE withdrawal_status = 'processing'
  AND transaction_digest = $1
  RETURNING processing_withdrawal_id, transaction_digest, transaction_bytes_base64, total_priority_fee, withdrawal_status, create_time
`

func (q *Queries) SetWithdrawalSuccess(ctx context.Context, transactionDigest string) (ProcessingWithdrawal, error) {
	row := q.db.QueryRow(ctx, setWithdrawalSuccess, transactionDigest)
	var i ProcessingWithdrawal
	err := row.Scan(
		&i.ProcessingWithdrawalID,
		&i.TransactionDigest,
		&i.TransactionBytesBase64,
		&i.TotalPriorityFee,
		&i.WithdrawalStatus,
		&i.CreateTime,
	)
	return i, err
}

const startWithdrawal = `-- name: StartWithdrawal :one
INSERT INTO withdrawals (
  account_id,
  withdraw_address,
  amount,
  priority_fee
) VALUES (
  $1, $2, $3, $4
)
RETURNING withdrawal_id, account_id, withdraw_address, amount, priority_fee, processing_withdrawal_id, create_time
`

type StartWithdrawalParams struct {
	AccountID       int64  `json:"account_id"`
	WithdrawAddress []byte `json:"withdraw_address"`
	Amount          int64  `json:"amount"`
	PriorityFee     int64  `json:"priority_fee"`
}

func (q *Queries) StartWithdrawal(ctx context.Context, arg StartWithdrawalParams) (Withdrawal, error) {
	row := q.db.QueryRow(ctx, startWithdrawal,
		arg.AccountID,
		arg.WithdrawAddress,
		arg.Amount,
		arg.PriorityFee,
	)
	var i Withdrawal
	err := row.Scan(
		&i.WithdrawalID,
		&i.AccountID,
		&i.WithdrawAddress,
		&i.Amount,
		&i.PriorityFee,
		&i.ProcessingWithdrawalID,
		&i.CreateTime,
	)
	return i, err
}
