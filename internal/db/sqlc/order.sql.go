// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: order.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelOrder = `-- name: CancelOrder :one
DELETE FROM active_orders
WHERE order_id = $1 and seller_id = $2
RETURNING order_id, service_id, seller_id, ask_price, quantity, create_time, order_expire_time, service_expire_time
`

type CancelOrderParams struct {
	OrderID  int64 `json:"order_id"`
	SellerID int64 `json:"seller_id"`
}

func (q *Queries) CancelOrder(ctx context.Context, arg CancelOrderParams) (ActiveOrder, error) {
	row := q.db.QueryRow(ctx, cancelOrder, arg.OrderID, arg.SellerID)
	var i ActiveOrder
	err := row.Scan(
		&i.OrderID,
		&i.ServiceID,
		&i.SellerID,
		&i.AskPrice,
		&i.Quantity,
		&i.CreateTime,
		&i.OrderExpireTime,
		&i.ServiceExpireTime,
	)
	return i, err
}

const claimFulfilledOrderOfQuantity = `-- name: ClaimFulfilledOrderOfQuantity :one
UPDATE fulfilled_orders
SET remaining_quantity = remaining_quantity - $1::bigint
WHERE order_fulfillment_id = $2::bigint
RETURNING order_fulfillment_id, service_id, order_id, buyer_id, seller_id, deal_price, deal_quantity, deal_time, remaining_quantity, service_expire_time
`

type ClaimFulfilledOrderOfQuantityParams struct {
	ClaimQuantity      int64 `json:"claim_quantity"`
	OrderFulfillmentID int64 `json:"order_fulfillment_id"`
}

func (q *Queries) ClaimFulfilledOrderOfQuantity(ctx context.Context, arg ClaimFulfilledOrderOfQuantityParams) (FulfilledOrder, error) {
	row := q.db.QueryRow(ctx, claimFulfilledOrderOfQuantity, arg.ClaimQuantity, arg.OrderFulfillmentID)
	var i FulfilledOrder
	err := row.Scan(
		&i.OrderFulfillmentID,
		&i.ServiceID,
		&i.OrderID,
		&i.BuyerID,
		&i.SellerID,
		&i.DealPrice,
		&i.DealQuantity,
		&i.DealTime,
		&i.RemainingQuantity,
		&i.ServiceExpireTime,
	)
	return i, err
}

const cleanExpiredFulfilledOrders = `-- name: CleanExpiredFulfilledOrders :many
DELETE FROM fulfilled_orders
WHERE remaining_quantity = 0
OR service_expire_time < CURRENT_TIMESTAMP
RETURNING order_fulfillment_id, service_id, order_id, buyer_id, seller_id, deal_price, deal_quantity, deal_time, remaining_quantity, service_expire_time
`

func (q *Queries) CleanExpiredFulfilledOrders(ctx context.Context) ([]FulfilledOrder, error) {
	rows, err := q.db.Query(ctx, cleanExpiredFulfilledOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FulfilledOrder{}
	for rows.Next() {
		var i FulfilledOrder
		if err := rows.Scan(
			&i.OrderFulfillmentID,
			&i.ServiceID,
			&i.OrderID,
			&i.BuyerID,
			&i.SellerID,
			&i.DealPrice,
			&i.DealQuantity,
			&i.DealTime,
			&i.RemainingQuantity,
			&i.ServiceExpireTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cleanInactiveOrders = `-- name: CleanInactiveOrders :many
DELETE FROM active_orders
WHERE quantity = 0
OR order_expire_time < CURRENT_TIMESTAMP
RETURNING order_id, service_id, seller_id, ask_price, quantity, create_time, order_expire_time, service_expire_time
`

func (q *Queries) CleanInactiveOrders(ctx context.Context) ([]ActiveOrder, error) {
	rows, err := q.db.Query(ctx, cleanInactiveOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActiveOrder{}
	for rows.Next() {
		var i ActiveOrder
		if err := rows.Scan(
			&i.OrderID,
			&i.ServiceID,
			&i.SellerID,
			&i.AskPrice,
			&i.Quantity,
			&i.CreateTime,
			&i.OrderExpireTime,
			&i.ServiceExpireTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO active_orders (
  seller_id,
  service_id,
  ask_price,
  quantity,
  create_time,
  order_expire_time,
  service_expire_time
) VALUES (
  $1, $2, $3, $4, CURRENT_TIMESTAMP, $5::timestamptz, $6::timestamptz
)
RETURNING order_id, service_id, seller_id, ask_price, quantity, create_time, order_expire_time, service_expire_time
`

type CreateOrderParams struct {
	SellerID          int64              `json:"seller_id"`
	ServiceID         int64              `json:"service_id"`
	AskPrice          int64              `json:"ask_price"`
	Quantity          int64              `json:"quantity"`
	OrderExpireTime   pgtype.Timestamptz `json:"order_expire_time"`
	ServiceExpireTime pgtype.Timestamptz `json:"service_expire_time"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (ActiveOrder, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.SellerID,
		arg.ServiceID,
		arg.AskPrice,
		arg.Quantity,
		arg.OrderExpireTime,
		arg.ServiceExpireTime,
	)
	var i ActiveOrder
	err := row.Scan(
		&i.OrderID,
		&i.ServiceID,
		&i.SellerID,
		&i.AskPrice,
		&i.Quantity,
		&i.CreateTime,
		&i.OrderExpireTime,
		&i.ServiceExpireTime,
	)
	return i, err
}

const listFulfilledOrders = `-- name: ListFulfilledOrders :many
SELECT order_fulfillment_id, service_id, order_id, buyer_id, seller_id, deal_price, deal_quantity, deal_time, remaining_quantity, service_expire_time FROM fulfilled_orders
WHERE buyer_id = $1
AND order_fulfillment_id >= $2
AND remaining_quantity >= $5
LIMIT $3
OFFSET $4
`

type ListFulfilledOrdersParams struct {
	BuyerID            int64 `json:"buyer_id"`
	OrderFulfillmentID int64 `json:"order_fulfillment_id"`
	Limit              int32 `json:"limit"`
	Offset             int32 `json:"offset"`
	RemainingQuantity  int64 `json:"remaining_quantity"`
}

func (q *Queries) ListFulfilledOrders(ctx context.Context, arg ListFulfilledOrdersParams) ([]FulfilledOrder, error) {
	rows, err := q.db.Query(ctx, listFulfilledOrders,
		arg.BuyerID,
		arg.OrderFulfillmentID,
		arg.Limit,
		arg.Offset,
		arg.RemainingQuantity,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FulfilledOrder{}
	for rows.Next() {
		var i FulfilledOrder
		if err := rows.Scan(
			&i.OrderFulfillmentID,
			&i.ServiceID,
			&i.OrderID,
			&i.BuyerID,
			&i.SellerID,
			&i.DealPrice,
			&i.DealQuantity,
			&i.DealTime,
			&i.RemainingQuantity,
			&i.ServiceExpireTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFulfilledOrdersByService = `-- name: ListFulfilledOrdersByService :many
SELECT order_fulfillment_id, service_id, order_id, buyer_id, seller_id, deal_price, deal_quantity, deal_time, remaining_quantity, service_expire_time FROM fulfilled_orders
WHERE buyer_id = $1
AND service_id = $2
AND order_fulfillment_id >= $3
AND remaining_quantity >= $6
LIMIT $4
OFFSET $5
`

type ListFulfilledOrdersByServiceParams struct {
	BuyerID            int64 `json:"buyer_id"`
	ServiceID          int64 `json:"service_id"`
	OrderFulfillmentID int64 `json:"order_fulfillment_id"`
	Limit              int32 `json:"limit"`
	Offset             int32 `json:"offset"`
	RemainingQuantity  int64 `json:"remaining_quantity"`
}

func (q *Queries) ListFulfilledOrdersByService(ctx context.Context, arg ListFulfilledOrdersByServiceParams) ([]FulfilledOrder, error) {
	rows, err := q.db.Query(ctx, listFulfilledOrdersByService,
		arg.BuyerID,
		arg.ServiceID,
		arg.OrderFulfillmentID,
		arg.Limit,
		arg.Offset,
		arg.RemainingQuantity,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FulfilledOrder{}
	for rows.Next() {
		var i FulfilledOrder
		if err := rows.Scan(
			&i.OrderFulfillmentID,
			&i.ServiceID,
			&i.OrderID,
			&i.BuyerID,
			&i.SellerID,
			&i.DealPrice,
			&i.DealQuantity,
			&i.DealTime,
			&i.RemainingQuantity,
			&i.ServiceExpireTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const matchOneOrder = `-- name: MatchOneOrder :one
WITH matched_order AS (
  SELECT 
    order_id
    , quantity
    , service_expire_time
  FROM active_orders a
  WHERE
    a.ask_price <= $1 AND
    quantity > 0 AND
    a.seller_id != $2 AND
    a.service_id = $3 AND
    a.service_expire_time >= $4 AND
    a.order_expire_time > CURRENT_TIMESTAMP
  ORDER BY a.ask_price ASC
  LIMIT 1
  FOR UPDATE SKIP LOCKED
), fulfilled_order AS (
  UPDATE active_orders b
  SET quantity = CASE
    WHEN b.quantity > $5 THEN
      b.quantity - $5
    ELSE
      0
    END
  FROM matched_order
  WHERE b.order_id = matched_order.order_id
  RETURNING
    b.order_id,
    $3 AS service_id,
    $2 AS buyer_id,
    seller_id,
    b.ask_price AS deal_price,
    CASE WHEN matched_order.quantity > $5 THEN $5 ELSE matched_order.quantity END AS deal_quantity,
    matched_order.service_expire_time
)
INSERT INTO fulfilled_orders (
  order_id,
  service_id,
  buyer_id,
  seller_id,
  deal_price,
  deal_quantity,
  remaining_quantity,
  service_expire_time
)
SELECT
  order_id,
  service_id,
  buyer_id,
  seller_id,
  deal_price,
  deal_quantity,
  deal_quantity,
  service_expire_time
FROM fulfilled_order
RETURNING order_fulfillment_id, service_id, order_id, buyer_id, seller_id, deal_price, deal_quantity, deal_time, remaining_quantity, service_expire_time
`

type MatchOneOrderParams struct {
	BidPrice      int64              `json:"bid_price"`
	BuyerID       int64              `json:"buyer_id"`
	ServiceID     int64              `json:"service_id"`
	MinExpireTime pgtype.Timestamptz `json:"min_expire_time"`
	BidQuantity   int64              `json:"bid_quantity"`
}

func (q *Queries) MatchOneOrder(ctx context.Context, arg MatchOneOrderParams) (FulfilledOrder, error) {
	row := q.db.QueryRow(ctx, matchOneOrder,
		arg.BidPrice,
		arg.BuyerID,
		arg.ServiceID,
		arg.MinExpireTime,
		arg.BidQuantity,
	)
	var i FulfilledOrder
	err := row.Scan(
		&i.OrderFulfillmentID,
		&i.ServiceID,
		&i.OrderID,
		&i.BuyerID,
		&i.SellerID,
		&i.DealPrice,
		&i.DealQuantity,
		&i.DealTime,
		&i.RemainingQuantity,
		&i.ServiceExpireTime,
	)
	return i, err
}

const newClaimOrder = `-- name: NewClaimOrder :one
INSERT INTO claimed_orders (
  order_fulfillment_id,
  audience_address,
  claim_quantity
) VALUES (
  $1, $2, $3
)
RETURNING order_claim_id, order_fulfillment_id, audience_address, claim_quantity, claim_time
`

type NewClaimOrderParams struct {
	OrderFulfillmentID int64  `json:"order_fulfillment_id"`
	AudienceAddress    []byte `json:"audience_address"`
	ClaimQuantity      int64  `json:"claim_quantity"`
}

func (q *Queries) NewClaimOrder(ctx context.Context, arg NewClaimOrderParams) (ClaimedOrder, error) {
	row := q.db.QueryRow(ctx, newClaimOrder, arg.OrderFulfillmentID, arg.AudienceAddress, arg.ClaimQuantity)
	var i ClaimedOrder
	err := row.Scan(
		&i.OrderClaimID,
		&i.OrderFulfillmentID,
		&i.AudienceAddress,
		&i.ClaimQuantity,
		&i.ClaimTime,
	)
	return i, err
}

const queryFulfilledOrder = `-- name: QueryFulfilledOrder :one
SELECT order_fulfillment_id, service_id, order_id, buyer_id, seller_id, deal_price, deal_quantity, deal_time, remaining_quantity, service_expire_time FROM fulfilled_orders
WHERE buyer_id = $1 AND order_fulfillment_id = $2
FOR UPDATE
`

type QueryFulfilledOrderParams struct {
	BuyerID            int64 `json:"buyer_id"`
	OrderFulfillmentID int64 `json:"order_fulfillment_id"`
}

func (q *Queries) QueryFulfilledOrder(ctx context.Context, arg QueryFulfilledOrderParams) (FulfilledOrder, error) {
	row := q.db.QueryRow(ctx, queryFulfilledOrder, arg.BuyerID, arg.OrderFulfillmentID)
	var i FulfilledOrder
	err := row.Scan(
		&i.OrderFulfillmentID,
		&i.ServiceID,
		&i.OrderID,
		&i.BuyerID,
		&i.SellerID,
		&i.DealPrice,
		&i.DealQuantity,
		&i.DealTime,
		&i.RemainingQuantity,
		&i.ServiceExpireTime,
	)
	return i, err
}
