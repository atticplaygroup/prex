// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: account.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addDepositRecord = `-- name: AddDepositRecord :one
INSERT INTO deposits (
  transaction_digest,
  epoch,
  account_id
) VALUES (
  $1, $2, $3
)
RETURNING deposit_id, transaction_digest, epoch, account_id
`

type AddDepositRecordParams struct {
	TransactionDigest string `json:"transaction_digest"`
	Epoch             int64  `json:"epoch"`
	AccountID         int64  `json:"account_id"`
}

func (q *Queries) AddDepositRecord(ctx context.Context, arg AddDepositRecordParams) (Deposit, error) {
	row := q.db.QueryRow(ctx, addDepositRecord, arg.TransactionDigest, arg.Epoch, arg.AccountID)
	var i Deposit
	err := row.Scan(
		&i.DepositID,
		&i.TransactionDigest,
		&i.Epoch,
		&i.AccountID,
	)
	return i, err
}

const changeBalance = `-- name: ChangeBalance :one
UPDATE accounts
SET balance = balance + $1
WHERE account_id = $2
RETURNING account_id, username, password, balance, create_time, expire_time, privilege
`

type ChangeBalanceParams struct {
	BalanceChange int64 `json:"balance_change"`
	AccountID     int64 `json:"account_id"`
}

func (q *Queries) ChangeBalance(ctx context.Context, arg ChangeBalanceParams) (Account, error) {
	row := q.db.QueryRow(ctx, changeBalance, arg.BalanceChange, arg.AccountID)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.Username,
		&i.Password,
		&i.Balance,
		&i.CreateTime,
		&i.ExpireTime,
		&i.Privilege,
	)
	return i, err
}

const changeBalanceByUsername = `-- name: ChangeBalanceByUsername :one
UPDATE accounts
SET balance = balance + $1
WHERE username = $2
RETURNING account_id, username, password, balance, create_time, expire_time, privilege
`

type ChangeBalanceByUsernameParams struct {
	BalanceChange int64  `json:"balance_change"`
	Username      string `json:"username"`
}

func (q *Queries) ChangeBalanceByUsername(ctx context.Context, arg ChangeBalanceByUsernameParams) (Account, error) {
	row := q.db.QueryRow(ctx, changeBalanceByUsername, arg.BalanceChange, arg.Username)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.Username,
		&i.Password,
		&i.Balance,
		&i.CreateTime,
		&i.ExpireTime,
		&i.Privilege,
	)
	return i, err
}

const deleteInvalidAccounts = `-- name: DeleteInvalidAccounts :many
DELETE FROM accounts
WHERE
  expire_time < CURRENT_TIMESTAMP
RETURNING account_id
`

func (q *Queries) DeleteInvalidAccounts(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, deleteInvalidAccounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var account_id int64
		if err := rows.Scan(&account_id); err != nil {
			return nil, err
		}
		items = append(items, account_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccount = `-- name: GetAccount :one
SELECT
  account_id, username, password, balance, create_time, expire_time, privilege
FROM accounts
WHERE username = $1
`

func (q *Queries) GetAccount(ctx context.Context, username string) (Account, error) {
	row := q.db.QueryRow(ctx, getAccount, username)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.Username,
		&i.Password,
		&i.Balance,
		&i.CreateTime,
		&i.ExpireTime,
		&i.Privilege,
	)
	return i, err
}

const queryBalance = `-- name: QueryBalance :one
SELECT account_id, username, password, balance, create_time, expire_time, privilege
FROM accounts
WHERE account_id = $1
AND expire_time > CURRENT_TIMESTAMP
`

func (q *Queries) QueryBalance(ctx context.Context, accountID int64) (Account, error) {
	row := q.db.QueryRow(ctx, queryBalance, accountID)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.Username,
		&i.Password,
		&i.Balance,
		&i.CreateTime,
		&i.ExpireTime,
		&i.Privilege,
	)
	return i, err
}

const queryBalanceForShare = `-- name: QueryBalanceForShare :one
SELECT account_id, username, password, balance, create_time, expire_time, privilege
FROM accounts
WHERE account_id = $1
AND expire_time > CURRENT_TIMESTAMP
FOR SHARE
`

func (q *Queries) QueryBalanceForShare(ctx context.Context, accountID int64) (Account, error) {
	row := q.db.QueryRow(ctx, queryBalanceForShare, accountID)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.Username,
		&i.Password,
		&i.Balance,
		&i.CreateTime,
		&i.ExpireTime,
		&i.Privilege,
	)
	return i, err
}

const upsertAccount = `-- name: UpsertAccount :one
INSERT INTO accounts (
  username,
  password,
  balance,
  privilege,
  create_time,
  expire_time
) VALUES (
  $1, $2, $3, $4, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP + $5::interval
)
ON CONFLICT (username) DO UPDATE SET
  balance = accounts.balance + EXCLUDED.balance,
  expire_time = accounts.expire_time + $5::interval
RETURNING account_id, username, password, balance, create_time, expire_time, privilege
`

type UpsertAccountParams struct {
	Username  string          `json:"username"`
	Password  string          `json:"password"`
	Balance   int64           `json:"balance"`
	Privilege string          `json:"privilege"`
	Ttl       pgtype.Interval `json:"ttl"`
}

func (q *Queries) UpsertAccount(ctx context.Context, arg UpsertAccountParams) (Account, error) {
	row := q.db.QueryRow(ctx, upsertAccount,
		arg.Username,
		arg.Password,
		arg.Balance,
		arg.Privilege,
		arg.Ttl,
	)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.Username,
		&i.Password,
		&i.Balance,
		&i.CreateTime,
		&i.ExpireTime,
		&i.Privilege,
	)
	return i, err
}
